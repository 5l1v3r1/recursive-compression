#!/usr/bin/env python
# -*- coding: UTF-8 -*-
__author__ = "Alexandre D'Hondt"
__version__ = "1.5"
__copyright__ = "A. D'Hondt"
__license__   = "agpl-3.0"
__training__ = "ZSIS CTF - Trivia - Shining (4 points)"
__doc__ = """
This tool allows to recursively decompress an archive, using multiple Linux decompression
 tools. It currently supports the following tools:
- bzip2
- tar
- unrar
- unxz
- arj
- lzma
- gunzip
- 7za
- unzip
"""
__examples__ = ["test.zip"]


# --------------------- IMPORTS SECTION ---------------------
import shutil
from collections import deque
from subprocess import check_output as chout, PIPE
from tinyscript import *


check_output = lambda *a, **kw: chout(list(map(b, a[0])), *a[1:], **kw)


# ------------------- TOOL'S LOGIC SECTION ------------------
class RecursiveDecompressor(object):
    FORMATS = {
        "7-zip archive data":    (["7za", "e"], "7z"),
        "ARJ archive data":      (["arj", "e"], "arj"),
        "bzip2 compressed data": (["bzip2", "-df"], None),
        "POSIX tar archive":     (["tar", "-xvf"], None),
        "RAR archive data":      (["unrar", "e"], None),
        "XZ compressed data":    (["unxz", "-df"], "xz"),
        "LZMA compressed data":  (["lzma", "-df"], "lzma"),
        "gzip compressed data":  (["gunzip", "-df"], "gz"),
        "Zip archive data":      (["unzip"], "zip"),
    }
    
    def __init__(self, archive):
        self.__cleanup = deque([], 2)
        self.__tmp = ".{}".format(archive)
        shutil.copy(archive, self.__tmp)  # create a hidden backup copy
        self.archive = archive
        self.result = None
        while self.decompress() is not None:
            continue
        shutil.move(self.__tmp, archive)  # restore the backup copy
        # remove all remaining files
        for i in range(len(self.__cleanup)):
            os.remove(self.__cleanup.pop())    
    
    def decompress(self):
        # check for archive format
        ft = check_output(['file', self.archive], stderr=PIPE).split(':', 1)[1]
        ft = " ".join(ft.strip().split()[:3]).rstrip(",")
        logger.debug(ft)
        try:
            cmd, ext = self.FORMATS[ft]
        except KeyError:  # if the archive format is unknown, stop recursion
            logger.warn("Nothing more to decompress")
            self.result = self.archive
            return
        # if the extension must be enforced, update archive's filename
        if ext is not None:
            if not ext.startswith("."):
                ext = "." + ext
            if not self.archive.endswith(ext):
                shutil.move(self.archive, self.archive + ext)
                self.archive += ext
        self.__cleanup.append(self.archive)
        # now decompress, finding the decompressed file by applying a diff
        #  with the old directory listing
        old = set(os.listdir("."))
        logger.info("Decompressing '{}'...".format(self.archive))
        _ = check_output(list(map(b, list(cmd) + [self.archive])), stderr=PIPE)
        try:
            self.archive = list(set(os.listdir(".")) - old)[0]
            if len(self.__cleanup) == 2:
                try:
                    os.remove(self.__cleanup.popleft())
                except OSError:  # occurs when the decompression tool already
                    pass         #  removes the old archive by itself
        except IndexError:   # occurs when the decompressed file's name is the
            pass             #  same as the uncompressed one
        logger.debug("=> {}".format(self.archive))
        return self.archive


# ---------------------- MAIN SECTION -----------------------
if __name__ == '__main__':
    parser.add_argument("archive", help="input archive")
    parser.add_argument("-d", dest="display", action="store_true",
                        help="display last decompressed file in terminal")
    initialize(globals())
    rd = RecursiveDecompressor(args.archive)
    if args.display:
        with open(rd.result, 'rb') as f:
            logger.success(f.read())
